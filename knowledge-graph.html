<!DOCTYPE html>
<html lang="en-IN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knowledge Graph - PolicyRadar</title>
    <meta name="description" content="Explore entity relationships in Indian policy news - see connections between ministries, regulators, companies, and policies.">
    <link rel="canonical" href="https://policyradar.in/knowledge-graph.html">
    
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üï∏Ô∏è</text></svg>">
    
    <style>
        /* ========================================
           CSS CUSTOM PROPERTIES
           ======================================== */
        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-card: #1e293b;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --border-color: #334155;
            --accent-primary: #3b82f6;
            --accent-secondary: #60a5fa;
            --accent-glow: rgba(59, 130, 246, 0.3);
            
            /* Node colors by type */
            --node-ministry: #f59e0b;
            --node-regulator: #ef4444;
            --node-company: #10b981;
            --node-policy: #8b5cf6;
            --node-sector: #06b6d4;
            --node-person: #ec4899;
            --node-default: #6b7280;
            
            --header-height: 64px;
        }
        
        /* ========================================
           RESET & BASE
           ======================================== */
        *, *::before, *::after {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }
        
        /* ========================================
           HEADER
           ======================================== */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1.5rem;
            z-index: 100;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .back-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            text-decoration: none;
            font-size: 0.875rem;
            transition: all 0.2s;
        }
        
        .back-btn:hover {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }
        
        .logo {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--accent-primary);
        }
        
        .header-center {
            flex: 1;
            max-width: 400px;
            margin: 0 1rem;
        }
        
        .search-container {
            position: relative;
        }
        
        .search-input {
            width: 100%;
            padding: 0.625rem 1rem 0.625rem 2.5rem;
            border: 1px solid var(--border-color);
            border-radius: 9999px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.875rem;
            outline: none;
            transition: all 0.2s;
        }
        
        .search-input:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px var(--accent-glow);
        }
        
        .search-input::placeholder {
            color: var(--text-muted);
        }
        
        .search-icon {
            position: absolute;
            left: 0.875rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
        }
        
        .search-results {
            position: absolute;
            top: calc(100% + 0.5rem);
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            max-height: 300px;
            overflow-y: auto;
            display: none;
            z-index: 200;
        }
        
        .search-results.visible {
            display: block;
        }
        
        .search-result-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            transition: background 0.2s;
        }
        
        .search-result-item:last-child {
            border-bottom: none;
        }
        
        .search-result-item:hover {
            background: var(--bg-primary);
        }
        
        .search-result-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .search-result-name {
            font-weight: 500;
        }
        
        .search-result-type {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-left: auto;
        }
        
        .header-right {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        /* ========================================
           CONTROLS
           ======================================== */
        .controls {
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 50;
        }
        
        .control-btn {
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1.25rem;
        }
        
        .control-btn:hover {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }
        
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .zoom-level {
            text-align: center;
            font-size: 0.75rem;
            color: var(--text-muted);
            padding: 0.25rem;
        }
        
        /* ========================================
           LEGEND
           ======================================== */
        .legend {
            position: fixed;
            top: calc(var(--header-height) + 1rem);
            left: 1rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            z-index: 50;
            min-width: 160px;
        }
        
        .legend-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 0.75rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.375rem 0;
            font-size: 0.8125rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: opacity 0.2s;
        }
        
        .legend-item.dimmed {
            opacity: 0.3;
        }
        
        .legend-item:hover {
            color: var(--text-primary);
        }
        
        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        /* ========================================
           CANVAS
           ======================================== */
        .canvas-container {
            position: fixed;
            top: var(--header-height);
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        #graph-canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        
        #graph-canvas:active {
            cursor: grabbing;
        }
        
        /* ========================================
           NODE TOOLTIP
           ======================================== */
        .tooltip {
            position: fixed;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 300px;
        }
        
        .tooltip.visible {
            opacity: 1;
        }
        
        .tooltip-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .tooltip-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .tooltip-name {
            font-weight: 600;
            font-size: 1rem;
        }
        
        .tooltip-type {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }
        
        .tooltip-stats {
            display: flex;
            gap: 1rem;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border-color);
        }
        
        .tooltip-stat {
            text-align: center;
        }
        
        .tooltip-stat-value {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--accent-primary);
        }
        
        .tooltip-stat-label {
            font-size: 0.625rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }
        
        /* ========================================
           DETAIL PANEL
           ======================================== */
        .detail-panel {
            position: fixed;
            top: var(--header-height);
            right: -400px;
            width: 400px;
            max-width: 90vw;
            height: calc(100vh - var(--header-height));
            background: var(--bg-card);
            border-left: 1px solid var(--border-color);
            z-index: 60;
            transition: right 0.3s ease;
            overflow-y: auto;
        }
        
        .detail-panel.open {
            right: 0;
        }
        
        .detail-header {
            position: sticky;
            top: 0;
            background: var(--bg-card);
            padding: 1.25rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .detail-title-group {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .detail-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }
        
        .detail-title {
            font-size: 1.25rem;
            font-weight: 600;
        }
        
        .detail-close {
            padding: 0.5rem;
            border: none;
            background: var(--bg-primary);
            border-radius: 6px;
            cursor: pointer;
            color: var(--text-muted);
            transition: all 0.2s;
        }
        
        .detail-close:hover {
            background: var(--accent-primary);
            color: white;
        }
        
        .detail-content {
            padding: 1.25rem;
        }
        
        .detail-section {
            margin-bottom: 1.5rem;
        }
        
        .detail-section-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 0.75rem;
        }
        
        .connections-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .connection-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.625rem 0.75rem;
            background: var(--bg-primary);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .connection-item:hover {
            background: var(--accent-glow);
        }
        
        .connection-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        .connection-name {
            flex: 1;
            font-size: 0.875rem;
        }
        
        .connection-strength {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        .article-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .article-item {
            padding: 0.75rem;
            background: var(--bg-primary);
            border-radius: 6px;
        }
        
        .article-item-title {
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.25rem;
        }
        
        .article-item-title a {
            color: var(--text-primary);
            text-decoration: none;
        }
        
        .article-item-title a:hover {
            color: var(--accent-primary);
        }
        
        .article-item-meta {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        /* ========================================
           LOADING
           ======================================== */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
        }
        
        .spinner {
            width: 48px;
            height: 48px;
            border: 4px solid var(--border-color);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* ========================================
           STATS BAR
           ======================================== */
        .stats-bar {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            display: flex;
            gap: 1rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            z-index: 50;
        }
        
        .stats-item {
            text-align: center;
        }
        
        .stats-value {
            font-size: 1.125rem;
            font-weight: 700;
            color: var(--accent-primary);
        }
        
        .stats-label {
            font-size: 0.625rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }
        
        /* ========================================
           MOBILE
           ======================================== */
        @media (max-width: 768px) {
            .header {
                flex-wrap: wrap;
                height: auto;
                padding: 0.75rem 1rem;
                gap: 0.75rem;
            }
            
            .header-center {
                order: 3;
                width: 100%;
                max-width: none;
                margin: 0;
            }
            
            .legend {
                top: auto;
                bottom: 5rem;
                left: 0.5rem;
                padding: 0.75rem;
                font-size: 0.75rem;
            }
            
            .controls {
                bottom: 5rem;
                right: 0.5rem;
            }
            
            .stats-bar {
                left: 0.5rem;
                right: 0.5rem;
                bottom: 0.5rem;
                justify-content: space-around;
            }
            
            .detail-panel {
                width: 100%;
                max-width: 100%;
            }
        }
        
        /* ========================================
           ACCESSIBILITY
           ======================================== */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }
        
        .skip-link {
            position: absolute;
            top: -100%;
            left: 0;
            background: var(--accent-primary);
            color: white;
            padding: 0.5rem 1rem;
            z-index: 1000;
        }
        
        .skip-link:focus {
            top: 0;
        }
    </style>
</head>
<body>
    <!-- Skip Link -->
    <a href="#graph-canvas" class="skip-link">Skip to graph</a>
    
    <!-- Screen Reader Announcements -->
    <div id="sr-announcer" class="sr-only" aria-live="polite"></div>
    
    <!-- Header -->
    <header class="header">
        <div class="header-left">
            <a href="/" class="back-btn">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M19 12H5M12 19l-7-7 7-7"/>
                </svg>
                Back
            </a>
            <span class="logo">üï∏Ô∏è Knowledge Graph</span>
        </div>
        
        <div class="header-center">
            <div class="search-container">
                <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"/>
                    <path d="M21 21l-4.35-4.35"/>
                </svg>
                <input type="text" id="search-input" class="search-input" placeholder="Search entities..." aria-label="Search entities">
                <div id="search-results" class="search-results"></div>
            </div>
        </div>
        
        <div class="header-right">
            <button class="control-btn" id="btn-reset" title="Reset view (R)">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                    <path d="M3 3v5h5"/>
                </svg>
            </button>
        </div>
    </header>
    
    <!-- Canvas -->
    <div class="canvas-container">
        <canvas id="graph-canvas" tabindex="0" aria-label="Knowledge graph visualization"></canvas>
    </div>
    
    <!-- Loading -->
    <div id="loading" class="loading">
        <div class="spinner"></div>
        <p>Building knowledge graph...</p>
    </div>
    
    <!-- Legend -->
    <div class="legend" id="legend">
        <div class="legend-title">Entity Types</div>
        <div class="legend-item" data-type="ministry">
            <span class="legend-dot" style="background: var(--node-ministry)"></span>
            Ministry
        </div>
        <div class="legend-item" data-type="regulator">
            <span class="legend-dot" style="background: var(--node-regulator)"></span>
            Regulator
        </div>
        <div class="legend-item" data-type="company">
            <span class="legend-dot" style="background: var(--node-company)"></span>
            Company
        </div>
        <div class="legend-item" data-type="policy">
            <span class="legend-dot" style="background: var(--node-policy)"></span>
            Policy
        </div>
        <div class="legend-item" data-type="sector">
            <span class="legend-dot" style="background: var(--node-sector)"></span>
            Sector
        </div>
    </div>
    
    <!-- Zoom Controls -->
    <div class="controls">
        <button class="control-btn" id="btn-zoom-in" title="Zoom in (+)">+</button>
        <div class="zoom-level" id="zoom-level">100%</div>
        <button class="control-btn" id="btn-zoom-out" title="Zoom out (-)">‚àí</button>
    </div>
    
    <!-- Stats Bar -->
    <div class="stats-bar">
        <div class="stats-item">
            <div class="stats-value" id="stat-nodes">0</div>
            <div class="stats-label">Entities</div>
        </div>
        <div class="stats-item">
            <div class="stats-value" id="stat-edges">0</div>
            <div class="stats-label">Connections</div>
        </div>
    </div>
    
    <!-- Tooltip -->
    <div id="tooltip" class="tooltip">
        <div class="tooltip-header">
            <span class="tooltip-dot" id="tooltip-dot"></span>
            <span class="tooltip-name" id="tooltip-name"></span>
        </div>
        <div class="tooltip-type" id="tooltip-type"></div>
        <div class="tooltip-stats">
            <div class="tooltip-stat">
                <div class="tooltip-stat-value" id="tooltip-connections">0</div>
                <div class="tooltip-stat-label">Connections</div>
            </div>
            <div class="tooltip-stat">
                <div class="tooltip-stat-value" id="tooltip-articles">0</div>
                <div class="tooltip-stat-label">Articles</div>
            </div>
        </div>
    </div>
    
    <!-- Detail Panel -->
    <div id="detail-panel" class="detail-panel" role="dialog" aria-labelledby="detail-title" aria-hidden="true">
        <div class="detail-header">
            <div class="detail-title-group">
                <span class="detail-dot" id="detail-dot"></span>
                <h2 id="detail-title" class="detail-title">Entity Name</h2>
            </div>
            <button class="detail-close" aria-label="Close panel">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M18 6L6 18M6 6l12 12"/>
                </svg>
            </button>
        </div>
        <div class="detail-content">
            <div class="detail-section">
                <h3 class="detail-section-title">Connected Entities</h3>
                <div id="connections-list" class="connections-list">
                    <!-- Connections added dynamically -->
                </div>
            </div>
            <div class="detail-section">
                <h3 class="detail-section-title">Recent Articles</h3>
                <div id="detail-articles" class="article-list">
                    <!-- Articles added dynamically -->
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // ========================================
        // CONFIGURATION
        // ========================================
        const CONFIG = {
            // Node appearance
            nodeRadius: { min: 8, max: 30 },
            nodeColors: {
                ministry: '#f59e0b',
                regulator: '#ef4444',
                company: '#10b981',
                policy: '#8b5cf6',
                sector: '#06b6d4',
                person: '#ec4899',
                default: '#6b7280',
            },
            
            // Edge appearance
            edgeColor: 'rgba(100, 116, 139, 0.3)',
            edgeHighlight: 'rgba(59, 130, 246, 0.8)',
            edgeWidth: { min: 0.5, max: 3 },
            
            // Physics simulation
            simulation: {
                centerForce: 0.005,      // Gentle pull to center
                chargeStrength: -500,    // Moderate repulsion
                linkDistance: 120,       // Comfortable spacing
                linkStrength: 0.15,      // Soft links
                velocityDecay: 0.6,      // Start with moderate damping
            },
            
            // Zoom
            zoom: { min: 0.3, max: 3, step: 0.2 },
            
            // Performance
            maxNodes: 200, // Switch to simplified rendering above this
        };
        
        // ========================================
        // STATE
        // ========================================
        const state = {
            nodes: [],
            edges: [],
            articles: [],
            
            // View
            zoom: 1,
            panX: 0,
            panY: 0,
            
            // Interaction
            selectedNode: null,
            hoveredNode: null,
            isDragging: false,
            dragNode: null,
            lastMouse: { x: 0, y: 0 },
            
            // Filters
            visibleTypes: new Set(['ministry', 'regulator', 'company', 'policy', 'sector']),
            searchQuery: '',
            highlightedNodes: new Set(),
        };
        
        // ========================================
        // CANVAS SETUP
        // ========================================
        const canvas = document.getElementById('graph-canvas');
        const ctx = canvas.getContext('2d');
        let animationId = null;
        
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
            ctx.scale(dpr, dpr);
            
            // Center the view
            state.panX = rect.width / 2;
            state.panY = rect.height / 2;
        }
        
        // ========================================
        // DATA LOADING
        // ========================================
        async function loadData() {
            try {
                const response = await fetch('/data/public_data.json');
                if (!response.ok) throw new Error('Failed to load data');
                
                const data = await response.json();
                state.articles = data.articles || [];
                
                // Extract entities and relationships
                buildGraph(state.articles);
                
                // Hide loading
                document.getElementById('loading').style.display = 'none';
                
                // Update stats
                document.getElementById('stat-nodes').textContent = state.nodes.length;
                document.getElementById('stat-edges').textContent = state.edges.length;
                
                // Start rendering
                startSimulation();
                
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('loading').innerHTML = '<p>Failed to load data. Please refresh.</p>';
            }
        }
        
        function buildGraph(articles) {
            const entityMap = new Map();
            const edgeMap = new Map();
            
            // Known entities for classification
            const REGULATORS = new Set(['RBI', 'SEBI', 'IRDAI', 'PFRDA', 'TRAI', 'CCI', 'NCLT', 'NGT', 'FSSAI', 'BIS', 'NPPA', 'CERC']);
            const MINISTRIES = new Set(['Finance Ministry', 'MoF', 'MeitY', 'DPIIT', 'Commerce Ministry', 'Home Ministry', 'Defence Ministry', 'External Affairs']);
            const POLICIES = new Set(['GST', 'PLI', 'DPDP', 'FDI', 'NEP', 'UPI', 'PMAY', 'PMJAY']);
            
            articles.forEach(article => {
                const text = `${article.title || ''} ${article.summary || ''}`;
                const entities = extractEntities(text);
                
                entities.forEach(entity => {
                    const key = entity.name.toLowerCase();
                    
                    if (!entityMap.has(key)) {
                        // Classify entity type
                        let type = 'default';
                        if (REGULATORS.has(entity.name)) type = 'regulator';
                        else if (MINISTRIES.has(entity.name) || entity.name.includes('Ministry')) type = 'ministry';
                        else if (POLICIES.has(entity.name)) type = 'policy';
                        else if (entity.name.includes('Ltd') || entity.name.includes('Inc')) type = 'company';
                        else if (article.category) type = 'sector';
                        
                        // Spread nodes in a circular pattern initially
                        const nodeIndex = entityMap.size;
                        const angle = (nodeIndex / 60) * 2 * Math.PI;
                        const radius = 200 + (nodeIndex % 5) * 80;
                        
                        entityMap.set(key, {
                            id: key,
                            name: entity.name,
                            type: type,
                            count: 0,
                            articles: [],
                            x: radius * Math.cos(angle),
                            y: radius * Math.sin(angle),
                            vx: 0,
                            vy: 0,
                        });
                    }
                    
                    const node = entityMap.get(key);
                    node.count++;
                    if (node.articles.length < 10) {
                        node.articles.push(article);
                    }
                });
                
                // Create edges between co-occurring entities
                for (let i = 0; i < entities.length; i++) {
                    for (let j = i + 1; j < entities.length; j++) {
                        const key = [entities[i].name, entities[j].name].sort().join('|||');
                        
                        if (!edgeMap.has(key)) {
                            edgeMap.set(key, {
                                source: entities[i].name.toLowerCase(),
                                target: entities[j].name.toLowerCase(),
                                weight: 0,
                            });
                        }
                        edgeMap.get(key).weight++;
                    }
                }
            });
            
            // Filter to top nodes by count
            state.nodes = Array.from(entityMap.values())
                .sort((a, b) => b.count - a.count)
                .slice(0, CONFIG.maxNodes);
            
            const nodeIds = new Set(state.nodes.map(n => n.id));
            
            // Filter edges to only include nodes in the graph
            state.edges = Array.from(edgeMap.values())
                .filter(e => nodeIds.has(e.source) && nodeIds.has(e.target))
                .sort((a, b) => b.weight - a.weight)
                .slice(0, 500); // Limit edges for performance
        }
        
        function extractEntities(text) {
            const entities = [];
            
            // Pattern for known entities (acronyms, proper nouns)
            const patterns = [
                /\b(RBI|SEBI|IRDAI|PFRDA|TRAI|CCI|NCLT|NGT|FSSAI|GST|PLI|DPDP|FDI|UPI|NPCI|ONDC|CBDC)\b/g,
                /\b(Ministry of [A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\b/g,
                /\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+(?:Ltd|Limited|Inc|Corporation|Bank|Authority))\b/g,
            ];
            
            patterns.forEach(pattern => {
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    entities.push({ name: match[1] || match[0] });
                }
            });
            
            return entities;
        }
        
        // ========================================
        // PHYSICS SIMULATION
        // ========================================
        let simulationTick = 0;
        let isSimulationSettled = false;
        
        function startSimulation() {
            simulationTick = 0;
            isSimulationSettled = false;
            
            function tick() {
                simulationTick++;
                
                // Apply forces with cooling
                applyForces();
                
                // Calculate total kinetic energy to detect settling
                let totalEnergy = 0;
                
                // Update positions with adaptive velocity decay (increases over time)
                const coolingFactor = Math.min(0.98, CONFIG.simulation.velocityDecay + simulationTick * 0.0005);
                
                state.nodes.forEach(node => {
                    node.x += node.vx;
                    node.y += node.vy;
                    node.vx *= coolingFactor;
                    node.vy *= coolingFactor;
                    totalEnergy += node.vx * node.vx + node.vy * node.vy;
                });
                
                // Check if simulation has settled (very low energy)
                if (totalEnergy < 0.1 || simulationTick > 500) {
                    isSimulationSettled = true;
                }
                
                // Render
                render();
                
                // Continue animation but only apply forces if not settled
                if (!isSimulationSettled || state.isDragging) {
                    animationId = requestAnimationFrame(tick);
                } else {
                    // Keep rendering for interactions but stop physics
                    animationId = requestAnimationFrame(renderLoop);
                }
            }
            
            tick();
        }
        
        // Render-only loop (no physics) for when simulation is settled
        function renderLoop() {
            render();
            if (state.isDragging || state.hoveredNode) {
                animationId = requestAnimationFrame(renderLoop);
            }
        }
        
        // Wake up simulation when user interacts
        function wakeSimulation() {
            if (isSimulationSettled) {
                isSimulationSettled = false;
                simulationTick = Math.max(0, simulationTick - 100); // Partial reset
                startSimulation();
            }
        }
        
        function applyForces() {
            // Reduce forces as simulation progresses
            const alpha = Math.max(0.1, 1 - simulationTick / 300);
            const { centerForce, chargeStrength, linkDistance, linkStrength } = CONFIG.simulation;
            
            // Center force
            state.nodes.forEach(node => {
                node.vx -= node.x * centerForce * alpha;
                node.vy -= node.y * centerForce * alpha;
            });
            
            // Repulsion between nodes (simplified for performance)
            for (let i = 0; i < state.nodes.length; i++) {
                for (let j = i + 1; j < state.nodes.length; j++) {
                    const nodeA = state.nodes[i];
                    const nodeB = state.nodes[j];
                    
                    const dx = nodeB.x - nodeA.x;
                    const dy = nodeB.y - nodeA.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    
                    // Minimum distance to prevent extreme forces
                    const minDist = 30;
                    const effectiveDist = Math.max(dist, minDist);
                    
                    const force = (chargeStrength * alpha) / (effectiveDist * effectiveDist);
                    const fx = (dx / dist) * force;
                    const fy = (dy / dist) * force;
                    
                    nodeA.vx -= fx;
                    nodeA.vy -= fy;
                    nodeB.vx += fx;
                    nodeB.vy += fy;
                }
            }
            
            // Link forces
            state.edges.forEach(edge => {
                const source = state.nodes.find(n => n.id === edge.source);
                const target = state.nodes.find(n => n.id === edge.target);
                
                if (!source || !target) return;
                
                const dx = target.x - source.x;
                const dy = target.y - source.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                
                const force = (dist - linkDistance) * linkStrength * alpha;
                const fx = (dx / dist) * force;
                const fy = (dy / dist) * force;
                
                source.vx += fx;
                source.vy += fy;
                target.vx -= fx;
                target.vy -= fy;
            });
        }
        
        // ========================================
        // RENDERING
        // ========================================
        function render() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            
            // Clear
            ctx.clearRect(0, 0, width, height);
            
            // Transform for pan and zoom
            ctx.save();
            ctx.translate(state.panX, state.panY);
            ctx.scale(state.zoom, state.zoom);
            
            // Draw edges
            state.edges.forEach(edge => {
                const source = state.nodes.find(n => n.id === edge.source);
                const target = state.nodes.find(n => n.id === edge.target);
                
                if (!source || !target) return;
                if (!state.visibleTypes.has(source.type) || !state.visibleTypes.has(target.type)) return;
                
                const isHighlighted = state.hoveredNode && 
                    (source.id === state.hoveredNode.id || target.id === state.hoveredNode.id);
                
                ctx.beginPath();
                ctx.moveTo(source.x, source.y);
                ctx.lineTo(target.x, target.y);
                ctx.strokeStyle = isHighlighted ? CONFIG.edgeHighlight : CONFIG.edgeColor;
                ctx.lineWidth = Math.min(CONFIG.edgeWidth.max, CONFIG.edgeWidth.min + edge.weight * 0.2);
                ctx.stroke();
            });
            
            // Draw nodes
            state.nodes.forEach(node => {
                if (!state.visibleTypes.has(node.type)) return;
                
                const radius = Math.min(
                    CONFIG.nodeRadius.max,
                    CONFIG.nodeRadius.min + Math.sqrt(node.count) * 2
                );
                
                const isHovered = state.hoveredNode?.id === node.id;
                const isSelected = state.selectedNode?.id === node.id;
                const isHighlighted = state.highlightedNodes.has(node.id);
                
                // Node circle
                ctx.beginPath();
                ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = CONFIG.nodeColors[node.type] || CONFIG.nodeColors.default;
                ctx.fill();
                
                // Highlight ring
                if (isHovered || isSelected || isHighlighted) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                // Label (show for more nodes at default zoom)
                if (radius > 10 || state.zoom > 0.8 || isHovered || isSelected) {
                    ctx.fillStyle = '#fff';
                    ctx.font = `${Math.max(10, radius * 0.8)}px -apple-system, sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Background for text
                    const text = node.name.length > 15 ? node.name.substring(0, 15) + '...' : node.name;
                    const textY = node.y + radius + 12;
                    
                    ctx.fillStyle = 'rgba(15, 23, 42, 0.8)';
                    ctx.fillRect(
                        node.x - ctx.measureText(text).width / 2 - 4,
                        textY - 8,
                        ctx.measureText(text).width + 8,
                        16
                    );
                    
                    ctx.fillStyle = '#f1f5f9';
                    ctx.fillText(text, node.x, textY);
                }
            });
            
            ctx.restore();
        }
        
        // ========================================
        // INTERACTION
        // ========================================
        function getNodeAtPosition(x, y) {
            // Transform screen coordinates to graph coordinates
            const gx = (x - state.panX) / state.zoom;
            const gy = (y - state.panY) / state.zoom;
            
            // Check nodes in reverse order (top-most first)
            for (let i = state.nodes.length - 1; i >= 0; i--) {
                const node = state.nodes[i];
                if (!state.visibleTypes.has(node.type)) continue;
                
                const radius = Math.min(
                    CONFIG.nodeRadius.max,
                    CONFIG.nodeRadius.min + Math.sqrt(node.count) * 2
                );
                
                const dx = gx - node.x;
                const dy = gy - node.y;
                
                if (dx * dx + dy * dy < radius * radius) {
                    return node;
                }
            }
            
            return null;
        }
        
        function showTooltip(node, x, y) {
            const tooltip = document.getElementById('tooltip');
            
            document.getElementById('tooltip-dot').style.background = CONFIG.nodeColors[node.type];
            document.getElementById('tooltip-name').textContent = node.name;
            document.getElementById('tooltip-type').textContent = node.type;
            document.getElementById('tooltip-connections').textContent = 
                state.edges.filter(e => e.source === node.id || e.target === node.id).length;
            document.getElementById('tooltip-articles').textContent = node.count;
            
            tooltip.style.left = `${x + 15}px`;
            tooltip.style.top = `${y + 15}px`;
            tooltip.classList.add('visible');
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }
        
        function showDetailPanel(node) {
            state.selectedNode = node;
            
            const color = CONFIG.nodeColors[node.type];
            document.getElementById('detail-dot').style.background = color;
            document.getElementById('detail-title').textContent = node.name;
            
            // Connections
            const connections = state.edges
                .filter(e => e.source === node.id || e.target === node.id)
                .map(e => {
                    const otherId = e.source === node.id ? e.target : e.source;
                    const other = state.nodes.find(n => n.id === otherId);
                    return other ? { node: other, weight: e.weight } : null;
                })
                .filter(Boolean)
                .sort((a, b) => b.weight - a.weight)
                .slice(0, 10);
            
            const connList = document.getElementById('connections-list');
            connList.innerHTML = connections.map(conn => `
                <div class="connection-item" data-node="${conn.node.id}">
                    <span class="connection-dot" style="background: ${CONFIG.nodeColors[conn.node.type]}"></span>
                    <span class="connection-name">${conn.node.name}</span>
                    <span class="connection-strength">${conn.weight}</span>
                </div>
            `).join('') || '<p style="color: var(--text-muted)">No connections</p>';
            
            // Add click handlers
            connList.querySelectorAll('.connection-item').forEach(item => {
                item.addEventListener('click', () => {
                    const n = state.nodes.find(node => node.id === item.dataset.node);
                    if (n) showDetailPanel(n);
                });
            });
            
            // Articles
            const articleList = document.getElementById('detail-articles');
            articleList.innerHTML = node.articles.slice(0, 5).map(article => `
                <div class="article-item">
                    <div class="article-item-title">
                        <a href="${article.url}" target="_blank" rel="noopener">${article.title}</a>
                    </div>
                    <div class="article-item-meta">
                        ${article.source_name} ¬∑ ${formatDate(article.publication_date)}
                    </div>
                </div>
            `).join('') || '<p style="color: var(--text-muted)">No articles</p>';
            
            document.getElementById('detail-panel').classList.add('open');
            document.getElementById('detail-panel').setAttribute('aria-hidden', 'false');
        }
        
        function closeDetailPanel() {
            document.getElementById('detail-panel').classList.remove('open');
            document.getElementById('detail-panel').setAttribute('aria-hidden', 'true');
            state.selectedNode = null;
        }
        
        // ========================================
        // ZOOM CONTROLS
        // ========================================
        function setZoom(newZoom) {
            state.zoom = Math.max(CONFIG.zoom.min, Math.min(CONFIG.zoom.max, newZoom));
            document.getElementById('zoom-level').textContent = `${Math.round(state.zoom * 100)}%`;
        }
        
        function zoomIn() {
            setZoom(state.zoom + CONFIG.zoom.step);
        }
        
        function zoomOut() {
            setZoom(state.zoom - CONFIG.zoom.step);
        }
        
        function resetView() {
            const rect = canvas.parentElement.getBoundingClientRect();
            state.panX = rect.width / 2;
            state.panY = rect.height / 2;
            setZoom(1);
        }
        
        // ========================================
        // SEARCH
        // ========================================
        function handleSearch(query) {
            state.searchQuery = query.toLowerCase();
            const results = document.getElementById('search-results');
            
            if (!query) {
                results.classList.remove('visible');
                state.highlightedNodes.clear();
                return;
            }
            
            const matches = state.nodes
                .filter(n => n.name.toLowerCase().includes(query.toLowerCase()))
                .slice(0, 10);
            
            if (matches.length === 0) {
                results.innerHTML = '<div class="search-result-item">No results found</div>';
            } else {
                results.innerHTML = matches.map(node => `
                    <div class="search-result-item" data-node="${node.id}">
                        <span class="search-result-dot" style="background: ${CONFIG.nodeColors[node.type]}"></span>
                        <span class="search-result-name">${node.name}</span>
                        <span class="search-result-type">${node.type}</span>
                    </div>
                `).join('');
                
                results.querySelectorAll('.search-result-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const node = state.nodes.find(n => n.id === item.dataset.node);
                        if (node) {
                            // Center on node
                            const rect = canvas.parentElement.getBoundingClientRect();
                            state.panX = rect.width / 2 - node.x * state.zoom;
                            state.panY = rect.height / 2 - node.y * state.zoom;
                            
                            // Show detail
                            showDetailPanel(node);
                            
                            // Highlight
                            state.highlightedNodes.clear();
                            state.highlightedNodes.add(node.id);
                        }
                        results.classList.remove('visible');
                    });
                });
            }
            
            results.classList.add('visible');
        }
        
        // ========================================
        // EVENT LISTENERS
        // ========================================
        function setupEventListeners() {
            // Canvas mouse events
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const node = getNodeAtPosition(x, y);
                
                if (node) {
                    state.dragNode = node;
                } else {
                    state.isDragging = true;
                }
                
                state.lastMouse = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (state.dragNode) {
                    // Drag node - wake simulation
                    wakeSimulation();
                    const dx = (e.clientX - state.lastMouse.x) / state.zoom;
                    const dy = (e.clientY - state.lastMouse.y) / state.zoom;
                    state.dragNode.x += dx;
                    state.dragNode.y += dy;
                    state.dragNode.vx = 0;
                    state.dragNode.vy = 0;
                } else if (state.isDragging) {
                    // Pan
                    state.panX += e.clientX - state.lastMouse.x;
                    state.panY += e.clientY - state.lastMouse.y;
                    render(); // Just render, no physics
                } else {
                    // Hover
                    const node = getNodeAtPosition(x, y);
                    
                    if (node !== state.hoveredNode) {
                        state.hoveredNode = node;
                        render(); // Update rendering for hover highlight
                        
                        if (node) {
                            showTooltip(node, e.clientX, e.clientY);
                            canvas.style.cursor = 'pointer';
                        } else {
                            hideTooltip();
                            canvas.style.cursor = 'grab';
                        }
                    } else if (node) {
                        // Update tooltip position
                        const tooltip = document.getElementById('tooltip');
                        tooltip.style.left = `${e.clientX + 15}px`;
                        tooltip.style.top = `${e.clientY + 15}px`;
                    }
                }
                
                state.lastMouse = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mouseup', (e) => {
                if (state.dragNode && !state.isDragging) {
                    // Click on node
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const node = getNodeAtPosition(x, y);
                    
                    if (node) {
                        showDetailPanel(node);
                    }
                }
                
                state.isDragging = false;
                state.dragNode = null;
            });
            
            canvas.addEventListener('mouseleave', () => {
                hideTooltip();
                state.isDragging = false;
                state.dragNode = null;
            });
            
            // Wheel zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -CONFIG.zoom.step : CONFIG.zoom.step;
                setZoom(state.zoom + delta);
            }, { passive: false });
            
            // Touch events for mobile
            let touchStart = null;
            let initialDistance = null;
            
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    state.isDragging = true;
                } else if (e.touches.length === 2) {
                    initialDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                }
            }, { passive: true });
            
            canvas.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && touchStart) {
                    state.panX += e.touches[0].clientX - touchStart.x;
                    state.panY += e.touches[0].clientY - touchStart.y;
                    touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2 && initialDistance) {
                    const currentDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    const scale = currentDistance / initialDistance;
                    setZoom(state.zoom * scale);
                    initialDistance = currentDistance;
                }
            }, { passive: true });
            
            canvas.addEventListener('touchend', () => {
                touchStart = null;
                initialDistance = null;
                state.isDragging = false;
            });
            
            // Zoom buttons
            document.getElementById('btn-zoom-in').addEventListener('click', zoomIn);
            document.getElementById('btn-zoom-out').addEventListener('click', zoomOut);
            document.getElementById('btn-reset').addEventListener('click', resetView);
            
            // Detail panel close
            document.querySelector('.detail-close').addEventListener('click', closeDetailPanel);
            
            // Search
            const searchInput = document.getElementById('search-input');
            let searchTimeout;
            
            searchInput.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => handleSearch(e.target.value), 200);
            });
            
            searchInput.addEventListener('focus', () => {
                if (searchInput.value) handleSearch(searchInput.value);
            });
            
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.search-container')) {
                    document.getElementById('search-results').classList.remove('visible');
                }
            });
            
            // Legend filtering
            document.querySelectorAll('.legend-item').forEach(item => {
                item.addEventListener('click', () => {
                    const type = item.dataset.type;
                    
                    if (state.visibleTypes.has(type)) {
                        state.visibleTypes.delete(type);
                        item.classList.add('dimmed');
                    } else {
                        state.visibleTypes.add(type);
                        item.classList.remove('dimmed');
                    }
                });
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT') {
                    if (e.key === 'Escape') {
                        e.target.blur();
                        document.getElementById('search-results').classList.remove('visible');
                    }
                    return;
                }
                
                switch (e.key) {
                    case '/':
                        e.preventDefault();
                        searchInput.focus();
                        break;
                    case '+':
                    case '=':
                        e.preventDefault();
                        zoomIn();
                        break;
                    case '-':
                        e.preventDefault();
                        zoomOut();
                        break;
                    case 'r':
                    case 'R':
                        e.preventDefault();
                        resetView();
                        break;
                    case 'Escape':
                        closeDetailPanel();
                        state.highlightedNodes.clear();
                        break;
                }
            });
            
            // Resize
            window.addEventListener('resize', resizeCanvas);
        }
        
        // ========================================
        // UTILITIES
        // ========================================
        function formatDate(dateStr) {
            if (!dateStr) return '';
            try {
                return new Date(dateStr).toLocaleDateString('en-IN', {
                    month: 'short',
                    day: 'numeric'
                });
            } catch {
                return '';
            }
        }
        
        function announce(message) {
            document.getElementById('sr-announcer').textContent = message;
        }
        
        // ========================================
        // INITIALIZATION
        // ========================================
        document.addEventListener('DOMContentLoaded', () => {
            resizeCanvas();
            setupEventListeners();
            loadData();
        });
    </script>
</body>
</html>
